---
title: "Summarizing Data: Advanced Techniques"
format: 
  revealjs:
    theme: dark
    preview-links: auto
    embed-resources: true # needed to allow for showing slides on a website (otherwise link is blank)
    # slide-tone: true # play sound on change - blind users
    
slide-number: c/t #h/v
#  width: 1600
#  height: 900
#logo: "images/??.jpg"
#logo: "https://www.rstudio.com/wp-content/uploads/2018/10/RStudio-Logo-Flat.png"
#footer: "[](https://rstudio-conf-2022.github.io/get-started-quarto/)"
#css: ["css/styles.css"]
#theme: simple
echo: true  # for code echo

#editor: visual

execute:
  #enabled: false
  freeze: auto
---


```{r message=FALSE, warning=FALSE, include=FALSE}
# secret functions
# source(here::here("r", "src", "color_format_text.R"))
```

```{r}
#| label: load-packages
#| include: false

#source(here::here("r", "my_functions.R"))
#source(here::here("r", "functions", "view_html.R"))
R.utils::sourceDirectory(here::here("r", "functions"))
```

```{r message=FALSE, warning=FALSE, include=FALSE}
library(tibble)
library(dplyr)
```

## **Libraries**

- `{tibble}`, `{dplyr}`

## **Create a Data Frame**

```{r}
DATA <- tribble(
  ~id, ~group, ~x, ~y,
  1, "a", 11, 30,
  2, "a", 21, 20,
  3, "a", 13, 33,
  4, "b", 51, NA,
  5, "b", 44, 20,
  6, "b", NA, 19
)
```

# **Standard Data-Summary Techniques**

# **Summarizing Vectors**

`$` operator for vector in data frame

```{r}
mean(DATA$x, na.rm = T)
mean(DATA$y, na.rm = T)
median(DATA$x, na.rm = T)
median(DATA$y, na.rm = T)
```

**NOTE:** The mean and median of `x` **differ**.


# **Summarizing Vectors in Data Frames**

## **1 Variable, 2 Metrics**

```{r}
DATA |>
  summarize(x = mean(x, na.rm = TRUE),
            x_median = median(x, na.rm = TRUE)
            )
```

- **Warning:** The mean and median of `x` are **the same**. The `median()` is computed based on the *new* value of `x` that is assigned by the first line in `summarize()` (e.g., `x = mean(x, na.rm = TRUE)`). You would want to use a *new* variable name.


## **1 Variable, 2 Metrics (Cont.)**

Assigning to names other than `x`:

```{r}
DATA |>
  summarize(mean = mean(x, na.rm = TRUE),
            median = median(x, na.rm = TRUE)
            )
```

**NOTE:** The mean and median of `x` **differ**.


## **2 Variables, 1 Metric**

```{r}
DATA |>
  summarize(x_mean = mean(x, na.rm = TRUE),
            y_mean = mean(y, na.rm = TRUE),
            )

```

## **2 Variables, 2 Metrics**

```{r}
DATA |>
  summarize(x_mean = mean(x, na.rm = TRUE),
            y_mean = mean(y, na.rm = TRUE),
            x_median = median(x, na.rm = TRUE),
            y_median = median(y, na.rm = TRUE)
            )

```

## **2 Variables, 2 Metrics with Grouping**

```{r}
DATA |>
  group_by(group) |>
  summarize(x_mean = mean(x, na.rm = TRUE),
            y_mean = mean(x, na.rm = TRUE),
            x_median = median(x, na.rm = TRUE),
            y_median = median(x, na.rm = TRUE)
            )
```


# **Advanced Data-Summary Techniques**

Coding each variable to include in the summarized data frame can be tedious. 

- use `across()`
- pass a list of functions

## **Summarizing Across with `dplyr::across()`**

`across()` is used when you want to iterate a function or set of functions across a multiple variables. The function will require you to pass arguments for the columns you want to summarize, the function(s) specifying how to summarize, and the names of the new output variables. 

```{.r}
across(.cols, 
       .fns, ..., 
       .names = NULL, 
       .unpack = FALSE
       )
```

## **`dplyr::across()`: Parameters/Arguments**

::: {.incremental}
- `.cols`: the columns to perform a function upon 
- `.fns`: the function(s) to apply to the column in `.cols`
- `.names`: a glue specification that describes how to name the output columns; use `{.col}` to stand for the selected column name, and `{.fn}` for the function being applied; defaults to `"{col}_{fn}"`
:::

## **`dplyr::across()`: Passing Arguments (Cont.)**

::: {.incremental} 
- `.cols = c(x, y)`
- `.fns = ~mean(x, na.rm = TRUE)`
- `.names = NULL` (default argument)
:::

## **`dplyr::across()`: Passing Arguments (Cont.)**

```{r}
DATA |>
  group_by(group) |>
  summarize(across(.cols = c(x, y), 
                   .fns = ~mean(.x, na.rm = TRUE)
                   )
            )
```

## **`dplyr::across()`: Passing Arguments (Cont.)**

Passing an argument to `.names`, `.names = "{col}_{fn}"`:

```{r}
DATA |>
  group_by(group) |>
  summarize(across(.cols = c(x, y), 
                   .fns = ~mean(.x, na.rm = TRUE),
                   .names = "{col}_{fn}"
                   )
            )
```

## **`dplyr::across()`: Passing Arguments (Cont.)**

Or using a quoted vector for `.cols`: `.cols = c("x", "y")`

```{r}
DATA |>
  group_by(group) |>
  summarize(across(.cols = c("x", "y"), 
                   .fns = ~mean(.x, na.rm = TRUE),
                   .names = "{col}_{fn}"
                   )
            )
```

## **`dplyr::across()`: Passing Arguments (Cont.)**

Or passing a quoted vector to `.cols`: 

::: {.incremental}
- must use `all_of()` or `any_of()` for variable selection
- `.cols = all_of(summarize_these)`
- `.cols = summarize_these` will produce a warning
:::

## **`dplyr::across()`: Passing Arguments (Cont.)**

```{r message=FALSE, warning=FALSE, include=FALSE}
summarize_these <- c("x", "y")  # create the vector to pass
```

```{r}
summarize_these <- c("x", "y")  # create the vector to pass

DATA |>
  group_by(group) |>
  summarize(across(.cols = any_of(summarize_these), 
                   .fns = ~mean(.x, na.rm = TRUE),
                   .names = "{col}_{fn}"
                   )
            )
```

- Defining a vector of variables can be a helpful solution when you have multiple summary tables for which you use the same variables.  


## **Annoyances with `across()`**

::: {.incremental}
- More complicated
- Although {col} is useful (e.g., `x` and `y`), {fn} results in a numeric value which is not diagnostic of the function
:::


# **Using Lists**

::: {.incremental}
- Lists hold all types of objects as their elements
- Vectors, data frames, functions
:::

# **Using Lists: Example of a List**

```{r message=FALSE, warning=FALSE, include=FALSE}
my_list <- 
  list(
    num_vect = c(1, 2),
    char_vect = c("2", "3", "5"),
    dataframe = DATA,
    afunction = function(x) {mean(x)}
    )
```

```{r}
my_list <- 
  list(
    num_vect = c(1, 2),
    char_vect = c("2", "3", "5"),
    dataframe = DATA,
    afunction = function(x) {mean(x)}
    )
```

# **Silly Example**

::: {.incremental}
- Call the function element to
- Perform on the numeric vector element
:::

# **Silly Example (Cont.)**

Obtain the mean (e.g., `afunction`) of the numeric vector (e.g., `num_vect`):

```{r}
my_list$afunction(my_list$num_vect)
```

## **Passing a List of Functions to `.fns`**

::: {.incremental}
- `.cols = c(x, y)`
- `.fns = list(~mean(x, na.rm = TRUE))`
:::

## **Passing a List of Functions to `.fns` (Cont.)**

```{r}
DATA |>
  group_by(group) |>
  summarize(across(.cols = c(x, y), 
                   .fns = list(~mean(.x, na.rm = TRUE)),
                   .names = "{col}_{fn}"
                   )
            )
```

## **Passing a List of Functions to `.fns` (Cont.)**

The `~` is use as a lambda-like operator that results in iterating the function over all instances of *x*. In this case, `list(~mean(x, na.rm = TRUE)`, the *x* is not referring to the `x` column in the data frame but instead the values in all variables passed to `.cols`. In this case, the *x* would be both `x` and `y`, in that order. 


## **Same Annoyances**

::: {.incremental}
- More complicated (requires remembering the function, in the list, and the ~)
- Although {col} is useful (e.g., `x` and `y`), {fn} results in a numeric value which is not diagnostic of the function
:::

## **Giving the List Elements Names**

::: {.incremental}
- `.cols = c(x, y)`
- `.fns = list(some_name = ~mean(x, na.rm = TRUE))`
:::

## **Giving the List Elements Names (Cont.)**

```{r}
DATA |>
  group_by(group) |>
  summarize(across(.cols = c(x, y), 
                   .fns = list(some_name = ~mean(.x, na.rm = TRUE)),
                   .names = "{col}_{fn}"
                   )
            )
```

## **Annoyances**

- Still complicated (requires remembering the function, in the list, and the ~)


## **Passing a List Object to `.fns`**

::: {.incremental}
- create `summary_funcs` list of function(s)
- `.fns = summary_funcs`
:::

## **Passing a List Object to `.fns` (Cont.)**

Create a list containing `~mean(.x, na.rm = TRUE))` used in previous example:

```{r}
summary_funcs <- list(
  mean = ~mean(.x, na.rm = TRUE)  
  )
```

## **Passing a List Object to `.fns` (Cont.)**

Then pass to `.fns`, `.fns = summary_funcs`:

```{r}
DATA |>
  summarize(across(.cols = c(x, y), 
                   .fns = summary_funcs,
                   .names = "{col}_{fn}"
                   )
            ) 
```

## **Passing a List Object to `.fns` (Cont.)**

Pair with `.cols = summarize_these` to summarize the variables in `summarize_these` using the function(s) in `summary_funcs`: 

```{.r}
DATA |>
  summarize(across(.cols = summarize_these,
                   .fns = summary_funcs,
                   .names = "{col}_{fn}"
                   )
            ) 
```

## **Annoyances/Benefits**

::: {.incremental}
- Requires creating other objects
- Simplifies the code
- Does not require remembering the functions, the list, and ~ after created once 
:::

## **Adding More Functions as List Elements**

Add functions to the list to accomplish more

```{r}
summary_funcs <- list(
  mean = ~mean(.x, na.rm = TRUE),
  median = ~median(.x, na.rm = TRUE),
  sd = ~sd(.x, na.rm = TRUE),
  n = ~length(na.omit(.x))  # no na.rm parameter in length()
  )
```


## **Passing the List Object to `.fns`: Grouping**

::: {.incremental}
- `group_by(group)`    
- `.fns = summary_funcs`
:::

## **Passing the List Object to `.fns`: Grouping (Cont.)**

```{r}
DATA |>
  group_by(group) |>
  summarize(across(.cols = c(x, y), 
                   .fns = summary_funcs,
                   .names = "{col}_{fn}"
                   )
            )
```

## **Annoyances/Benefits**

::: {.incremental}
- Creating and remembering the list object name
- **Solution:** Add an .R script to your functions directory and make a code snippet for the object name. 
:::
