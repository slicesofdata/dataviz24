---
title: "**Joining Relational Data**"
author: "Gabriel I. Cook"
#date: "`r Sys.Date()`"
#date: "`r format(Sys.time(), '%d %B, %Y')`"

execute:
  #enabled: false
  freeze: auto

---

```{r message=FALSE, warning=FALSE, include=FALSE}
# secret functions
# source(here::here("r", "src", "color_format_text.R"))
```


```{r}
#| label: load-packages
#| include: false

#library()
source(here::here("r", "my_functions.R"))

```

# **Overview**

In this module, we will cover how to join data frames that are related in some way. For example, perhaps you have multiple data frames containing data from the same participants and you need to combine them all so that you can summarize, visualize, or model the data. Students familiar with `SQL` (Structured Query Language) should have some experience with joining relational data. The joining or merging process is often a large component of data science projects, especially those that involve collaborators cleaning separate components that need to be merged together. 

You can run `SQL` code within an R Markdown code block but there are other libraries like **{sqldf}** that allow you to include `SQL` to perform data queries. 

For those who wish to dig deeper into learning `SQL`, there are [tutorials here](https://www.w3resource.com/sql/tutorials.php).

```{r message=FALSE, warning=FALSE, include=FALSE}
#[](https://dept.stat.lsa.umich.edu/~jerrick/courses/stat701/notes/sql.html)
#[dplyr](https://solutions.posit.co/connections/db/getting-started/database-queries/)

```

## **Readings and Preparation**

*Before Class*: First, read to familiarize yourself with the concepts rather than master them. I will assume that you attend class with some level of basic understanding of concepts and working of functions. The goal of reading should be to understand and implement code functions as well as support your understanding and help your troubleshooting of problems. This cannot happen if you just read the content without interacting with it, however reading is absolutely essential to being successful during class time. Work through some examples so that you have a good idea of your level of understanding and confidence. 

*Class*: In class, some functions and concepts will be introduced and we will practice implementing code through exercises. 


## **Supplementary Readings (Optional)**

```{r eval=FALSE, warning=FALSE, include=FALSE}
# **To Do**
# 
## **Supplementary Readings**

#- [R Workflow Basics](https://r4ds.hadley.nz/data-transform)
```

- [Joining Data](https://r4ds.hadley.nz/joins)

## **Libraries** 

- **{here}** `r packageVersion("here")`: for file path management
- **{dplyr}** `r packageVersion("dplyr")`: for joining data frames 

More generally:

- **{tidyverse}** `r packageVersion("tidyverse")`: the tidyverse ecosystem

```{r message=FALSE, warning=FALSE}
library(dplyr)
```


# **Creating Data Frames to Join**

Let's say that you have three data frames assigned to `A`, `B`, and `C`. Each contains different variables and/or participants. 

Data frame `A` contains heights and weights for different individuals, who appear to be uniquely identify by some numeric code.

```{r}
(A <- tibble::tribble(
  ~id, ~height, ~weight,
  1111, 60, 128,
  2211, NA, 120,
  9811, 60, 149,
  3000, 65, 140,
))
```

Data frame `B` contains data on cities and ages for different individuals, who also appear to be uniquely identify by some numeric code.

```{r}
(B <- tibble::tribble(
  ~id, ~city, ~age,
  1111, "Claremont", 22,
  2211, "Dallas", 25,
  9811, "Akron", 38,
  3050, NA, 50
))
```

Data frame `C` contains names, who appear to be uniquely identify by some numeric code.

```{r}
(C <- tibble::tribble(
  ~id, ~name,
  1111, "Sally",
  2211, "Jane", 
  9811, NA,
  NA, "Kelly"
))
```

All three data frames appear to have at least one common variable, `id` even thought the data frames don't contain all of the same ids (e.g., 3050). If you know that `id` is a unique identifier, this could be a way to merge the data from these folks with other data associated with them. The question is how to join the data frames. 

# **Merge/Join using base R's `merge()`**

```{.r}
merge(x, y)
```

**Key Parameters/Arguments**

- `x`, `y`: data frames, or objects to be coerced to one
- `by`, `by.x`, `by.y`: specifications for the matching column

Joining `A` and `B`:

```{r}
merge(x = A, 
      y = B, 
      by = "id"
      )
```

We see that the returned data frame contains 3 rows and 5 columns. Although there are `NA` values for some variables, the merged data frame contains the column variables from both data frames. However, the `id`s that are `NA` will be dropped. Similarly, `id == 3050` is also dropped because the other data frames don't contain that individual.

Joining `A` and `C`:

```{r}
merge(x = A, 
      y = C, 
      by = "id"
      )
```

We see that the returned data frame contains 3 rows and 4 columns. Although there are `NA` values for some variables, the merged data frame contains the column variables from both data frames. However, you see that when `id` has value of `NA` for that row, that row is dropped from the merge. This resulted in a data frame with only 3 rows/individuals.

Joining `B` and `C`:

```{r}
merge(x = B, 
      y = C, 
      by = "id"
      )
```

This merge performs similarly to merging `A` and `C` because there are `id` value of `NA` and the omission of `id == 3050`.


# **Full Join using `dplyr::full_join()`**

A *full join* is used when you want to **join all rows from two data frames. When you combine the data frames using some matching value and including NA where there are no matches.

```{r eval=FALSE, include=FALSE}
#When you want to completely join two data frames, a *full join* would join the two data frames so that the data frame would **combine all rows from both data frames by some unique value** including NA where there are no matches.
```

```{.r}
full_join(
  x,
  y
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
)
```

**Key Parameters/Arguments**

- `x`, `y`: data frames, or objects to be coerced to one
- `by`: specifications for the matching column

Joining `A` and `B`:

```{r}
full_join(x = A, 
          y = B, 
          by = "id"
          )
```

For the most part, this `full_join()` works the same a `merge()` but with some differences. 
Whereas `merge()` sorts the returned data frame by the `by` argument, `full_join()` does not. Also, `full_join()` includes a row of data for `id == 3050`.

Joining `A` and `C`:

```{r}
full_join(x = A, 
          y = C, 
          by = "id"
          )
```

Joining `B` and `C`:

```{r}
full_join(x = B, 
          y = C, 
          by = "id"
          )
```

Similarly, you see that `full_join()` maintains data from both data frames even if there are `NA` values anywhere.


# **Left Join using `dplyr::left_join()`**

A *left join* will return all rows from the *left* data frame (e.g., the argument passed to `x`) and the matched rows from the right data frame (e.g., the argument passed to `y`). If there's no match in the right data frame, it returns `NA` for the columns from the right data frame, `y`.

```{.r}
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = NULL
```

**Key Parameters/Arguments**

- `x`, `y`: data frames, or objects to be coerced to one.
- `by`: specifications for the matching column

Joining `B` left and `A`:

```{r}
left_join(x = A, 
          y = B, 
          by = "id"
          )
```

Here, `left_join()` takes `B` and joins it *left*, into `A`. What is returned is `A` along with any data in `B` that can be matched to the `id` in `A`. If there is an `id` in `B` that is not in `A`, it won't be included.


Joining `C` left into `A`:

```{r}
left_join(x = A, 
          y = C, 
          by = "id"
          )
```

With these data frames, `left_join()` takes `C` and joins it *left*, into `C`. What is returned is `B` along with any data in `C` that can be matched to the `id` in `B`. 

Joining `C` left into `B`:

```{r}
left_join(x = B, 
          y = C, 
          by = "id"
          )
```

Joining `B` left into `C`:

Remember that `C` contains an `NA` in `id`.

```{r}
left_join(x = C, 
          y = B, 
          by = "id"
          )

```

When we `left_join()` takes `B` and joins it *left*, into `C`, the data frame includes the `NA` row for `id`.



# **Joining More than 2 Data Frames**

When you have multiple data frames, you have to think about how you will join two first, and then join another to that joined data frame, and so on.

We will join `A` and `B` and assign the joined data frame to `AB`.

```{r}
AB <- 
  full_join(
    x = A, 
    y = B, 
    by = "id"
  )
```

```{r}
AB
```

Now, we will join `C` with `AB` and assign it to `ABC` to represent all three data frames.

```{r}
ABC <- 
  full_join(
    x = AB, 
    y = C, 
    by = "id"
  )
```

```{r}
ABC
```


## **Writing a Function**

You can also write a function to help you. Here, we can make a function to take a list of data frames and cycles through them to return a data frame based on `full_join()`.

```{r}
full_join_data_frames_in_list <- function(list, by) {
  if (missing(by)) {
    message("Please specify the 'by' parameter for merging.")
    return(NULL)
  } else {
    joined <- Reduce(function(x, y) dplyr::full_join(x, y, by = by), list)
    return(joined)
  }
}
```

Put the data frames in a list:

```{r}
ABC_list <- list(A, B, C)
```

Pass the list to the `list` parameter and supply the `by` argument as a string.

```{r}
full_join_data_frames_in_list(list = ABC_list,
                              by = "id"
                              )
```


# **Summary**

When you are working with data obtained from different sources or when you split a large data set into pieces that need to joined later, joining or merging data frames will be required. There are several ways to join data frames as described here but also others like `inner_join()` not addressed here. Moreover, join functions have additional parameters not addressed in this brief module. Each join function serves a special purpose which may best suit your use case. 


