---
title: "**Strings, Factors, and Regular Expressions**"
author: "Gabriel I. Cook"
#date: "`r Sys.Date()`"
date: "`r format(Sys.time(), '%d %B, %Y')`"

execute:
  #enabled: false
  freeze: auto
---

```{r message=FALSE, warning=FALSE, include=FALSE}
# huber text
huber_pdf <- "https://www.markhuberdatascience.org/_files/ugd/c2b9b6_543ea42a1ea64e32b4440b34ffd71635.pdf"
front_matter <- 10
huber_intro_ch <- glue::glue(huber_pdf,"#page=",front_matter + 3)
huber_rmarkdown_ch <- glue::glue(huber_pdf,"#page=",front_matter + 10)
huber_graphing_ch <- glue::glue(huber_pdf,"#page=",front_matter + 17)
huber_transformation_ch <- glue::glue(huber_pdf,"#page=",front_matter + 59) # 5
huber_summaries_ch <- glue::glue(huber_pdf,"#page=",front_matter + 71)
huber_eda_var_ch <- glue::glue(huber_pdf,"#page=",front_matter + 81)
huber_eda_covar_ch <- glue::glue(huber_pdf,"#page=",front_matter + 93)
huber_import_ch <- glue::glue(huber_pdf,"#page=",front_matter + 103)
huber_tidy_data_ch <- glue::glue(huber_pdf,"#page=",front_matter + 123)
huber_relational_ch <- glue::glue(huber_pdf,"#page=",front_matter + 141)
huber_filtering_joins_ch <- glue::glue(huber_pdf,"#page=",front_matter + 150)
huber_strings_ch <- glue::glue(huber_pdf,"#page=",front_matter + 155)
huber_regex_ch <- glue::glue(huber_pdf,"#page=",front_matter + 162)
huber_using_regex_ch <- glue::glue(huber_pdf,"#page=",front_matter + 170)
huber_func_patterns_ch <- glue::glue(huber_pdf,"#page=",front_matter + 182)
huber_factors_ch <- glue::glue(huber_pdf,"#page=",front_matter + 186)
huber_sql_ch <- glue::glue(huber_pdf,"#page=",front_matter + 199)
huber_writing_functions_ch <- glue::glue(huber_pdf,"#page=",front_matter + 232)
huber_modeling_ch <- glue::glue(huber_pdf,"#page=",front_matter + 241)
```

```{r}
#| label: load-packages
#| include: false

R.utils::sourceDirectory(here::here("r", "functions"))
```

```{r include=FALSE}
# # see also https://stats.stackexchange.com/questions/381877/whether-to-use-factors-in-r-and-when-ordered-factors
```


# **Overview**

In this module, we work with strings, character vectors, and factors. The focus will be on factors so if you desire to skip over the section on strings, that is fine.


## **Readings and Preparation**

*Before Class*: First, read to familiarize yourself with the concepts rather than master them. I will assume that you attend class with some level of basic understanding of concepts and working of functions. The goal of reading should be to understand and implement code functions as well as support your understanding and help your troubleshooting of problems. This cannot happen if you just read the content without interacting with it, however reading is absolutely essential to being successful during class time. Work through some examples so that you have a good idea of your level of understanding and confidence. 

*Class*: In class, some functions and concepts will be introduced and we will practice implementing code through exercises. 


```{r eval=FALSE, warning=FALSE, include=FALSE}
# **To Do**
# 
# https://uoftcoders.github.io/studyGroup/lessons/r/intermediate/lesson/
## **Supplementary Readings**

#- [R Workflow Basics](https://r4ds.hadley.nz/data-transform)
```


## **Libraries** 

- **{here}** `r packageVersion("here")`: for file path management
- **{dplyr}** `r packageVersion("dplyr")`: for data frame manipulation


Others:

- **{forcats}** `r packageVersion("forcats")`: for file path management


# **Strings**

A string is an ordered list of symbols. For example `"Male"` would be a string 

The **{stringr}** library contains many functions for handling strings and is part of the **{tidyverse}** ecosystem.

```{r}
string_1 <- 'My favorite string used single quotes.'
string_2 <- "My second favorite string uses double quotes." 
```

```{r}
string_1
```

`string_1` prints on screen with double quotes. Quotes do not matter except inside of strings. For example, you cannot have double quotes inside a string of double quotes. You can, however, have single quotes inside of a string with double quotes and vice versa. 


```{r}
string_3 <- 'My favorite string used "single" quotes.'
string_4 <- "My second favorite string uses 'double' quotes." 
```

```{r}
date_string <- "10/31/2008"

dates_string <- "10/31/2008, 01/08/2009"
```

```{r}
date_string

dates_string
```

## **Splitting Strings**

Splitting strings into pieces is easy used `stringr::str_split()` or `stringr::str_split_fixed()`. The functions return a `list()` of character vectors. 

### **Splitting a simple string by space**

We can try to split a string based on finding a pattern that is an empty string but because there is no space, the returned object is a `list()` of character vectors containing only one in the vector.

```{r}
stringr::str_split(date_string, pattern = " ")
```

By contrast, because `dates_string` contains a space, the returned object is a `list()` of character vectors containing two elements. 

```{r}
stringr::str_split(dates_string, pattern = " ")
```

Using `unlist()`, you can convert the list into a vector, which you see has a `length()` of two (e.g., two dates).

```{r}
unlist(stringr::str_split(dates_string, pattern = " "))

length(unlist(stringr::str_split(dates_string, pattern = " ")))
```

Notice, however, that the first vector element contains a comma. This is because the split is based on `" "` which appears after the comma.  

### **Splitting a string by comma**

```{r}
stringr::str_split(dates_string, pattern = ",")
```

The first vector element contains no comma. Neither does the second. That's because the string was split based on the comma. The second element contains a space because the `","` was followed by as space.

```{r}
stringr::str_split(dates_string, pattern = ",")
```

If this pattern held for the entire string, you could split by a comma followed by a space.

```{r}
stringr::str_split(dates_string, pattern = ", ")
```

Neither vector element contains a space or a comma.


### **Splitting a string by multiple delimiters**

Strings can be split by multiple delimiter patterns. If the pattern is a space or a comma, adding them in a `[]` will split the `dates_string` based on either the space or the comma. 

```{r}
stringr::str_split(dates_string, pattern = "[ ,]")

stringr::str_split(dates_string, pattern = "[, ]")  # same thing: order does not matter
```

In this case, there are three vector elements but the second one contains an empty string. If you wanted to extract all dates from a string, that might not be your solution. Of course, if your string is messy, it might contain commas or spaces and not always both together. For example, if your string is `"10/31/2008, 01/08/2009 01/11/2023"`, some dates are separated by a comma and some a space.

Trying to split by pattern `"[, ]"` will split by one or the other but not both.

```{r}
stringr::str_split("10/31/2008, 01/08/2009 01/11/2023", pattern = "[, ]")
```

You have four vector elements and one is an empty string. This may not be what you want. Changing the pattern to `"[, ]+"` will allow you to match more than one The `+` is a quantifier to the pattern will match **one or more occurrences** of the preceding character class or characters.

```{r}
stringr::str_split("10/31/2008, 01/08/2009 01/11/2023", pattern = "[, ]+")
```

We have three elements, all of which are dates.


### **Splitting a string and extracting a specific element**


```{r}
stringr::str_split_fixed("10/31/2008, 01/08/2009 01/11/2023", pattern = "/", n = 3)
```


### **Splitting a string with a regular expression**

If you wanted to split only by digits, you could use a regular expression that looks for a digit pattern.  `"[/d+]"

```{r}
stringr::str_split(dates_string, pattern = "[d+]")
```

### **Splitting a string with a regular expression and limiting the number of splits**


```{r}
stringr::str_split(dates_string, pattern = "[/d+]", n = 2)

```


# **Factors**

As part of data preparation or cleaning, you will likely have to create factor variables. A factor variable that represents nominal categories in data. Factors typically represent qualitative data, such as group membership, levels of a factor, or labels. Factors are particularly useful for statistical analysis and modeling. Factors look like character objects but they are different and they come in different flavors serving different purposes.  

- **Fixed set of levels**: A factor variable has a fixed set of possible values known as levels. Each level represents a distinct category or group within the variable. 

- **Ordered or unordered**: Factor variables can be either ordered or unordered. Ordered factors have a meaningful order among their levels, while unordered factors do not. An example of an ordered factor would be ranks or ratings for example low, medium, and high groups.  

- **Factor levels**: You can specify factor levels explicitly using the `levels()` function or R will infer levels based on the unique values present in the data. It's important to ensure that factor levels are correctly specified to avoid unexpected behavior in statistical analyses.

- **Statistical modeling**: Many statistical functions and modeling techniques, such as linear regression or ANOVA, automatically treat factor variables differently from numeric variables. They use factors to understand categorical differences and estimate coefficients or perform hypothesis tests.


## **Creating Factors**

Let's get some data and create some factor objects to represent factor variables.

```{r}
DATA <- data.frame(
  var1 = c(1, 3, 4, 5),
  var2 = c(100, 650, 890, 20),
  var3 = c(1.0, .6, .9, .98),
  group = c("B", "A", "B", "A")
  )

gt::gt(DATA)
```

In order to convert the vector variables into factors, we can use `as.factor()` from base R or `forcats::as_factor()`. 

```{.r}
factor(x = character(), 
       levels, 
       labels = levels,
       exclude = NA, 
       ordered = is.ordered(x), 
       nmax = NA
       )
```


**Key Parameters/Arguments**

- `x`: a vector of data, usually taking a small number of distinct values.
- `levels`:	an optional vector of the unique values (as character strings) that x might have taken. The default is the unique set of values taken by as.character(x), sorted into increasing order of x. Note that this set can be specified as smaller than sort(unique(x)).
- `labels`: either an optional character vector of labels for the levels (in the same order as levels after removing those in exclude), or a character string of length 1. Duplicated values in labels can be used to map different values of x to the same factor level.
- `ordered`: logical flag to determine if the levels should be regarded as ordered (in the order given)

```{r eval=FALSE, include=FALSE}
#don't run
as.factor(DATA$group)

forcats::as_factor(DATA$group)
```

### **Levels vs. Labels**

In brief, `levels` are the input whereas `labels` are the output for `factor()`. A factor has a level attribute, which is set by the `labels` argument. 

When you convert the vector to a factor, the factor object has *levels* as seen in the print out. All factors have levels but importantly, you must attend to the ordering of those levels.

The print out appears to indicate that the first level is `r as.character(as.factor(DATA$group)[1])` and the second level is `r as.character(as.factor(DATA$group)[2])`,

The `levels()` function, however, will tell us the actual order, so let's verify whether that assumption is true. 

```{r}
levels(as.factor(DATA$group))
```

Wrapping both functions in `levels()` is informative. First, the functions are returning different ordered. Second, `factor()` reorders the levels alphabetically. This order may appear trivial but the order matters when performing statistical modeling. For example, linear regression involving factor/categorical predictors using `lm()` will treat the first level as the base category to which all other levels will be compared. When a baseline or control group is not positioned first alphabetically, you will need to change the order.

And what about numbers?

```{r}
factor_a = factor(c("1", "8", "3", "5", "2"))

levels(factor_a)
```

```{r}
factor_b = forcats::as_factor(c("1", "8", "3", "5", "2"))

levels(factor_b)
```

If you wanted more details, the the attributes of the object can be examined using `attribute()`. The class is a factor and the levels are the unique values. Importantly, there is no label attribute.

```{r}
attributes(factor_a)
```

Again, you see the two functions use the data differently; `factor()` reorders numerically. As the data scientist, you need to know how the function operates.



## **Mutating Factors**

Variables that you want to make into factors are typically in a data frame, so let's mutate factors in a data frame.

```{r}
DATA |>
  mutate(
    factor_1 = factor(group),
    factor_2 = as.factor(group),
    factor_3 = as.factor(var1)
    ) |>
  glimpse()
```

You see the data frame's structure lists the new variables as factors.


## **Unordered Factors**

Factor variable levels and labels require some order. 

For example, let's create some some vectors that could be columns in a data frame.

```{r}
factor_a = factor(c("1", "8", "3", "5", "2"))

factor_b = factor(c("1", "8", "3", "5", "2"))

attributes(factor_a)
```


```{r}
factor_a

factor_b
```


## **Factor Levels and Labels**

Looking at the data frame, we see that there are some numeric and character variables but no factors.

```{r echo=FALSE}
DATA |> glimpse()
```







We can create three factors. The *first* factor can be a simple factor based on the character vector `group`. Using `factor()` will convert it to a factor variable, which will contain levels for each unique character type. 
The *second* factor will make use of the `labels` parameter to which we can pass a character vector of labels. The vector passed to `labels` will need to be the same length as the unique elements, so use `unique()` to ensure proper labeling. If your vector is of an incorrect length, you will receive an error stating `invalid 'labels'`. You could have one string label (e.g., `"My Label"`) but R will create levels by appending a number as a suffix to the string, which likely won't be as helpful (see `factor2b`). Finally, the *third* factor would make use of the `labels` and the `levels` parameters to which we can pass a character vector of labels and levels. 

```{r}
DATA$group |> unique()

DATA <-
  DATA |>
  mutate(
    factor_1  = factor(x = group),
    factor_2a = factor(x = group,
                       labels = c("Old", "Young")
                       ),
    factor_2b = factor(x = group,
                       labels = c("My Label")
                       ),
    factor_2c = factor(x = group,
                       levels = c("Old", "Young")
                       ),    
    factor_3 = factor(x = group,
                      levels = c("A", "B"),
                      labels = c("Young", "Old")   # intentionally reversed 
                      )
    )
```

```{r echo=FALSE}
gt::gt(DATA)
```

Piping the data frame to `glimpse()` will allow you to take inventory of the factors created.

```{r}
DATA |> glimpse()
```

The variable are not flagged as `<fct>`.


### **Inspecting Factor Levels**

```{r echo=FALSE}
gt::gt(DATA)
```

**Factor 1**

Let's inspect the variable by `pull()`ing it from the data frame.

```{r}
DATA |>
  pull(factor_1) 
```

You see that the vector along with all `r length(DATA$factor_1)` elements. There are also are `r length(levels(DATA$factor_1))` levels listed. To inspect just the levels, pipe the variable to `levels()`.

```{r}
DATA |>
  pull(factor_1) |>
  levels()
```

The levels take on the character elements. For the rows where `group` is `A`, `factor_1` is shown as `A` also. 

**Factor 2a**

```{r}
DATA |>
  pull(factor_2a)
```

The levels take on the levels specified in the function. Note that the levels are returned alphabetically, `"Old"` before `"Young"`. Do not be fooled, however. This order is not based on the level but rather on the label. For example, `labels = c("Young", "Old")` corresponded to `levels = c("A", "B")`). Because `"A"` is alphabetically before `"B"`, then `"Young"` will appear before `"Old"`. To make this distinction more clear, we will compare `factor_2a` to `factor_3`.


In the data frame, the rows where `group` is `A`, `factor_2a` is now shown as `Old` rather than `A`. 

```{r}
gt::gt(DATA)
```

**Factor 2b**

```{r}
DATA |>
  pull(factor_2b) 
```

The levels take on increments of the specified level. Note that they are presented alphanumerically, again based on the label, though this distinction is not clear.

**Factor 2c**

```{r}
DATA |>
  pull(factor_2c) 
```

This factor is problematic and is created incorrectly. Specifying the `levels` resulted in the creation of a factor variable with `NA` values across the rows. 

**Factor 3** 

```{r}
DATA |>
  pull(factor_3)
```

The levels take on the levels specified in the function. Note that they are **not** presented alphabetically but rather in the order of the levels (e.g., `labels = c("Young", "Old")`) paired to the labels (`levels = c("A", "B")`). Because `"A"` is alphabetically before `"B"`, then `"Young"` will appear before `"Old"`.

**Note:** Remember that unordered factors actually have an order, which is based on the underlying characters or level. 


## **Ordered Factors**

Ordered factors differ from unordered factors in that they are ordered to represent some ordering of levels of a variable. Variables like race, college major, sex, etc. have no order to them. Variables like tumor stage, satisfaction rating, etc. have an order to them. Some values represent outcomes that are less than or greater than others.

Ordered factors should be used when there are more than two categories that are ordinal. Beyond the ordering of the values, ordered factors in statistical models impose constraints on the data that are not imposed with unordered factors. In other words, the magnitude and direction of effects of an outcome variable that is associated with the ordered factor predictor will obey that ordering. 
Thus, ordering of categories is equivalent to a constraint on the parameter space in the model.

The documentation states that ordered is *"logical flag to determine if the levels should be regarded as ordered (in the order given)"*


### **And Example with Character Vectors**

Taking variable to create into a factor and specifying `ordered = TRUE` will create a new variable that is ordered. 

```{r}
DATA <-
  DATA |>
  mutate(
    factor_4a = factor(x = group,
                      ordered = TRUE
                      )
  )
```

The factor levels take on the order values in alphabetical order. A problem will arise if this order may not be the order that you need. Always make sure your ordering is created correctly. 

```{r}
DATA |> pull(factor_4a)
```

The attributes so that the object class is now "ordered" and "factor".

```{r}
DATA |> pull(factor_4a) |> attributes()
```

#### **Adjusting the `levels` Order**

A safe approach to creating ordered factors is to ensure that you specify the order rather than assume R will read your mind. Do not assume that the alphabetical or alphanumeric order is the proper ordering of the factor. If the letters A and B represented grades, A > B rather that A < B. Similarly, Young < Old but without you controlling the order, Old < Young. Your ordered factor would then be incorrect. 

Passing `levels = c("B", "A")` will ensure that A > B.

```{r}
DATA <-
  DATA |>
  mutate(
    factor_4b = factor(x = group,
                       levels = c("B", "A"),
                       ordered = TRUE
                       )
  )
```

The factor levels now take on the order passed to `levels`. 

```{r}
DATA |> pull(factor_4b)
```

If you want to add different labels, pass a character vector to `labels`. 

```{r}
DATA <-
  DATA |>
  mutate(
    factor_4c = factor(x = group,
                       levels = c("B", "A"),
                       labels = c("Young", "Old"),
                       ordered = TRUE
                       )
  )
```

The factor levels now take on the order passed to `levels`. 

```{r}
DATA |> pull(factor_4c)
```

Comparing the factor variables, versions a, b, and c  

```{r}
DATA |> select(contains("4")) |> gt::gt()
```

### **And Example with Character Vectors**

When your variable that you want to use for creating a factor is character in nature, the `levels` would need a character vector. 

```{r}
DATA <-
  DATA |>
  mutate(
    factor_4 = factor(x = group,
                      levels = c("A", "B"),
                      labels = c("Young", "Old"),
                      ordered = TRUE
                      )
  )
```

Let's take inventory of the data frame. 

```{r}
DATA |> glimpse()
```

Now, `factor_4` is shown as `<ord>`, which represents it is an ordered factor. Looking at the data frame, the levels and the labels look just like those for `factor_3`. 

```{r}
DATA |> gt::gt()
```

Nothing appears visually different between `factor_3` and `factor_4` in the data frame. We know that `factor_4` is ordered, however. Let's see what happens if we inspect the variable and its levels. 

```{r}
DATA |>
  pull(factor_4)
```

Now we see something different. The elements of the factor are listed as well as the levels. Importantly, the `<` indicates an order to the levels such that one level is less than/greater than the other. 


### **And Example with Numeric Vectors**

Let's create another ordered factor. In this instance, the vector used to make the factor is numeric. Assume that the numeric values in `var1` represent satisfaction responses to a question like *"How satisfied are you with your purchase?"*. The options available were 1 = "very dissatisfied", 2 = "dissatisfied", 3 = "neutral", 4= "satisfied", 5 = "very satisfied". If you wanted to use the responses as a grouping variable as a predictor for another variables, you could treat them as an ordered categorical variable or even some numeric value. Responses options clearly have an order to them but the order may not be equivalent. Making the levels ordered would create such an order to them. 

Looking at the values in `var1`, you see that they are numbers: `r DATA$var1`. All numbers have not been used either. For example, the "dissatisfied" option was not used by anyone. 

```{r}
DATA$var1
```

Because `var1` is numeric, pass a numeric vector to `levels` and a character vector to `labels`. If the variable you are trying to convert into the factors is character and not numeric, your vector passed to `levels` would be character as well.

```{r}
DATA <-
  DATA |>
  mutate(factor_5a = factor(var1, 
                           levels = 1:5,     # or c(1, 2, 3, 4, 5)
                           labels = c("very dissatisfied",
                                      "dissatisfied", 
                                      "neutral", 
                                      "satisfied", 
                                      "very satisfied"
                                      ),
                           ordered = TRUE
                           )
       ) 
```



```{r}
DATA |>
  pull(factor_5a)
```

If your variable is numeric and you do not pass an argument of the labels, you will receive an error. 


```{r}
DATA |> gt::gt()
```

# **Summary**

Factors represent categorical groupings of data that are not numeric. They can be unordered for which all levels of the factor will be treated the same but they can also be ordered. Ordered factors provide information about a hierarchy of the levels, which will be relevant for building appropriate statistical models that depend on the order. 

# **Session Information**

```{r}
sessioninfo::session_info()
```
